"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LdapEntry = exports.batch = void 0;
const ldapjs_1 = require("ldapjs");
const node_util_1 = require("node:util");
const stream_1 = require("stream");
const filterReplacements = {
    '\0': '\\00',
    '(': '\\28',
    ')': '\\29',
    '*': '\\2a',
    '\\': '\\5c'
};
const dnReplacements = {
    '"': '\\"',
    '#': '\\#',
    '+': '\\+',
    ',': '\\,',
    ';': '\\;',
    '<': '\\<',
    '=': '\\=',
    '>': '\\>',
    '\\': '\\\\',
    ' ': '\\ '
};
const utfDecoder = new node_util_1.TextDecoder('utf8', { fatal: true });
function valToString(val) {
    if (typeof val === 'boolean')
        return val ? 'TRUE' : 'FALSE';
    if (typeof val === 'number')
        return String(val);
    return val;
}
function searchForDN(dn) {
    const [first, ...restComponents] = dn.split(/(?<!\\),/);
    const basedn = restComponents.join(',');
    const [attr, ...restVal] = first.split(/=/);
    const val = restVal.join('=').replace(/(?<!\\)\\/, '').replace(/\\\\/, '\\');
    return { basedn, attr, val };
}
function batch(input, batchLimit = 100) {
    const ret = [];
    if (!(input === null || input === void 0 ? void 0 : input.length))
        return [[]];
    for (let i = 0; i < input.length; i += batchLimit) {
        ret.push(input.slice(i, i + batchLimit));
    }
    return ret;
}
exports.batch = batch;
function batchOnBase(searches, batchLimit = 100) {
    var _a;
    var _b;
    const store = {};
    for (const s of searches) {
        (_a = store[_b = s.basedn]) !== null && _a !== void 0 ? _a : (store[_b] = []);
        store[s.basedn].push(new ldapjs_1.EqualityFilter({ attribute: s.attr, value: s.val }));
    }
    const ret = {};
    for (const basedn of Object.keys(store)) {
        const batches = batch(store[basedn], batchLimit);
        ret[basedn] = batches.map(filters => new ldapjs_1.OrFilter({ filters }));
    }
    return ret;
}
class Ldap {
    constructor(config = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.loadPairs = new Map();
        this.loadPromises = {};
        if (!config.url) {
            const secure = (_a = config.secure) !== null && _a !== void 0 ? _a : process.env.LDAP_SECURE;
            const host = (_c = (_b = config.host) !== null && _b !== void 0 ? _b : process.env.LDAP_HOST) !== null && _c !== void 0 ? _c : '';
            const port = (_d = config.port) !== null && _d !== void 0 ? _d : process.env.LDAP_PORT;
            delete config.secure;
            delete config.host;
            delete config.port;
            config.url = `${secure ? 'ldaps://' : 'ldap://'}${host}:${port !== null && port !== void 0 ? port : (secure ? '636' : '389')}`;
        }
        this.console = (_e = config.logger) !== null && _e !== void 0 ? _e : console;
        this.bindDN = (_g = (_f = config.bindDN) !== null && _f !== void 0 ? _f : process.env.LDAP_DN) !== null && _g !== void 0 ? _g : '';
        this.bindCredentials = (_k = (_j = (_h = config.bindCredentials) !== null && _h !== void 0 ? _h : process.env.LDAP_PASSWORD) !== null && _j !== void 0 ? _j : process.env.LDAP_PASS) !== null && _k !== void 0 ? _k : '';
        delete config.bindDN;
        delete config.bindCredentials;
        if (!config.reconnect || config.reconnect === true)
            config.reconnect = {};
        if (!config.reconnect.initialDelay)
            config.reconnect.initialDelay = 500;
        if (!config.reconnect.failAfter)
            config.reconnect.failAfter = Number.MAX_SAFE_INTEGER;
        if (!config.reconnect.maxDelay)
            config.reconnect.maxDelay = 5000;
        this.config = config;
        this.poolSize = (_l = config.poolSize) !== null && _l !== void 0 ? _l : (parseInt((_m = process.env.LDAP_POOLSIZE) !== null && _m !== void 0 ? _m : 'NaN') || 5);
        this.clients = [];
        this.poolQueue = [];
    }
    async connect() {
        const client = (0, ldapjs_1.createClient)(this.config);
        client.busy = true;
        this.clients.push(client);
        try {
            return await new Promise((resolve, reject) => {
                client.on('connect', () => {
                    client.removeAllListeners('error');
                    client.removeAllListeners('connectError');
                    client.removeAllListeners('setupError');
                    client.on('error', e => { reject(e); });
                    client.bind(this.bindDN, this.bindCredentials, err => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        client.removeAllListeners('error');
                        client.on('error', e => { this.console.warn('Caught an error on ldap client, it is probably a connection problem that will auto-reconnect.', e.message); });
                        resolve(client);
                    });
                });
                client.on('error', (err) => {
                    reject(err);
                });
                client.on('connectError', (err) => {
                    reject(err);
                });
                client.on('setupError', (err) => {
                    reject(err);
                });
            });
        }
        catch (e) {
            client.destroy();
            this.clients = this.clients.filter(c => c !== client);
            throw e;
        }
    }
    async getClient() {
        let client = this.clients.find(c => !c.busy);
        if (!client) {
            if (this.clients.length < this.poolSize) {
                client = await this.connect();
            }
            else {
                client = await new Promise(resolve => {
                    this.poolQueue.push(client => {
                        resolve(client);
                    });
                });
            }
        }
        client.busy = true;
        return client;
    }
    release(client) {
        var _a;
        client.busy = false;
        const nextInQueue = this.poolQueue.shift();
        if (nextInQueue)
            nextInQueue(client);
        else if (this.clients.every(c => !c.busy))
            (_a = this.closeRequest) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    async close() {
        if (this.closeRequest)
            return;
        if (this.clients.some(c => c.busy)) {
            await new Promise(resolve => {
                this.closeRequest = resolve;
            });
            this.closeRequest = undefined;
        }
        for (const client of this.clients)
            client.unbind();
        this.clients = [];
    }
    async wait() {
        let loops = 0;
        while (true) {
            try {
                const client = await this.getClient();
                this.release(client);
            }
            catch (e) {
                if (loops++ < 2)
                    this.console.warn('Unable to connect to LDAP. Trying again in 2 seconds.');
                else if (typeof this.config.reconnect === 'object' && loops > (this.config.reconnect.failAfter / 2000)) {
                    throw new Error('Unable to connect to LDAP after ' + (loops * 2) + ' seconds.');
                }
                else
                    this.console.error('Unable to connect to LDAP. Trying again in 2 seconds.');
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }
    async get(base, options, controls) {
        return (await this.search(base, options, controls))[0];
    }
    async load(dn, attributes) {
        var _a;
        var _b;
        const { basedn, attr, val } = searchForDN(dn);
        const attrKey = JSON.stringify(attributes) + basedn;
        if (!this.loadPairs.has(attrKey))
            this.loadPairs.set(attrKey, new Set());
        this.loadPairs.get(attrKey).add(this.filter `(${attr}=${val})`);
        (_a = (_b = this.loadPromises)[attrKey]) !== null && _a !== void 0 ? _a : (_b[attrKey] = new Promise((resolve, reject) => {
            setTimeout(() => {
                this.loadPromises[attrKey] = undefined;
                const filters = Array.from(this.loadPairs.get(attrKey));
                this.loadPairs.delete(attrKey);
                const ret = new Map();
                const batches = batch(filters);
                const promises = [];
                for (const filters of batches) {
                    promises.push(this.search(basedn, { scope: 'sub', filter: `(|${filters.join('')})`, attributes }).then(results => {
                        for (const entry of results)
                            ret.set(entry.dn, entry);
                    }));
                }
                Promise.all(promises).then(() => { resolve(ret); }).catch(reject);
            }, 0);
        }));
        const entries = await this.loadPromises[attrKey];
        return entries.get(dn);
    }
    async search(base, options, controls) {
        const stream = this.stream(base, options, controls);
        const results = [];
        for await (const result of stream) {
            results.push(result);
        }
        return results;
    }
    stream(base, options = {}, controls) {
        if (options.paged == null || options.paged === true)
            options.paged = {};
        if (typeof options.paged === 'object') {
            if (!options.paged.pageSize)
                options.paged.pageSize = 200;
            options.paged.pagePause = true;
        }
        let unpause;
        let paused = true;
        let canceled = false;
        const stream = new stream_1.Readable({ objectMode: true, autoDestroy: true });
        stream._read = () => {
            paused = false;
            unpause === null || unpause === void 0 ? void 0 : unpause();
            unpause = undefined;
        };
        stream._destroy = (err, cb) => {
            canceled = true;
            cb(err);
        };
        const stacktraceError = {};
        Error.captureStackTrace(stacktraceError, this.stream);
        const sendError = (e) => {
            var _a, _b;
            if (canceled)
                return;
            e.clientstack = e.stack;
            e.stack = ((_a = stacktraceError.stack) !== null && _a !== void 0 ? _a : '').replace(/^Error:/, `Error: ${(_b = e.message) !== null && _b !== void 0 ? _b : ''}`);
            stream.emit('error', e);
        };
        this.getClient().then(client => {
            (0, stream_1.finished)(stream, () => { this.release(client); });
            client.search(base, options !== null && options !== void 0 ? options : {}, controls !== null && controls !== void 0 ? controls : [], (err, result) => {
                if (err) {
                    sendError(err);
                    return;
                }
                result.on('searchEntry', data => {
                    if (canceled)
                        return;
                    if (!stream.push(new LdapEntry(data, this)))
                        paused = true;
                });
                result.on('page', (result, cb) => {
                    if (paused && !canceled)
                        unpause = cb;
                    else
                        cb === null || cb === void 0 ? void 0 : cb();
                });
                result.on('error', sendError);
                result.on('end', (result) => {
                    var _a, _b;
                    if (canceled)
                        return;
                    if ((result === null || result === void 0 ? void 0 : result.status) === 0) {
                        stream.push(null);
                    }
                    else {
                        sendError(new Error(`${(_a = result === null || result === void 0 ? void 0 : result.errorMessage) !== null && _a !== void 0 ? _a : 'LDAP Search Failed'}\nStatus: ${(_b = result === null || result === void 0 ? void 0 : result.status) !== null && _b !== void 0 ? _b : 'undefined'}`));
                    }
                });
            });
        }).catch(sendError);
        return stream;
    }
    async useClient(callback) {
        const client = await this.getClient();
        try {
            return await callback(client);
        }
        finally {
            this.release(client);
        }
    }
    async modify(dn, operationOrChanges, modification) {
        const changes = Array.isArray(operationOrChanges)
            ? operationOrChanges.map(c => new ldapjs_1.Change(c))
            : [new ldapjs_1.Change({ operation: operationOrChanges, modification })];
        return await this.useClient(async (client) => await new Promise((resolve, reject) => {
            client.modify(dn, changes, err => {
                if (err)
                    reject(err);
                else
                    resolve(true);
            });
        }));
    }
    /**
     * Add an object into the system.
     */
    async add(newDn, entry) {
        return await this.useClient(async (client) => await new Promise((resolve, reject) => {
            client.add(newDn, entry, err => {
                if (err)
                    reject(err);
                else
                    resolve(true);
            });
        }));
    }
    /**
     * Remove an object from the system.
     */
    async remove(dn) {
        return await this.useClient(async (client) => await new Promise((resolve, reject) => {
            client.del(dn, err => {
                if (err)
                    reject(err);
                else
                    resolve(true);
            });
        }));
    }
    /**
     * Rename an object.
     */
    async modifyDN(oldDn, newDn) {
        return await this.useClient(async (client) => await new Promise((resolve, reject) => {
            client.modifyDN(oldDn, newDn, err => {
                if (err)
                    reject(err);
                else
                    resolve(true);
            });
        }));
    }
    /**
     * Use this method to completely replace an attribute. If you use it on an array attribute,
     * any existing values will be lost.
     */
    async setAttribute(dn, attribute, val) {
        const values = (Array.isArray(val) ? val : (val == null ? [] : [val])).map(valToString);
        return await this.modify(dn, 'replace', { type: attribute, values });
    }
    /**
     * Use this method to completely replace multiple attributes. If any of the given attributes
     * are array attributes, any existing values will be lost.
     *
     * If you need to mix set and push operations, you can do multiple round trips or you can send
     * multiple operations to the `modify` method.
     */
    async setAttributes(dn, modification) {
        const changes = Object.entries(modification).map(([attr, val]) => ({ operation: 'replace', modification: { type: attr, values: (Array.isArray(val) ? val : (val == null ? [] : [val])).map(valToString) } }));
        return await this.modify(dn, changes);
    }
    /**
     * Use this method to add more values to an array attribute without removing any existing values. Any
     * values that already exist will be ignored (if you used a raw 'modify' operation, you'd get an error).
     */
    async pushAttribute(dn, attribute, valueOrValues) {
        const values = Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues];
        const current = await this.get(dn);
        // the ldap client only returns an array when there are 2 or more elements
        // if there is only one element, it comes back as a scalar
        const attr = current.all(attribute);
        const existingValues = new Set(Array.isArray(attr) ? attr : [attr]);
        const newValues = values.filter(v => !existingValues.has(v));
        if (newValues.length === 0)
            return true;
        return await this.modify(dn, 'add', { type: attribute, values: newValues });
    }
    /**
     * Use this method to remove the specified values from an array attribute while leaving any other
     * values in place. Any values that don't already exist will be ignored (if you used a raw 'modify'
     * operation, you'd get an error).
     */
    async pullAttribute(dn, attribute, valueOrValues) {
        const values = Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues];
        const current = await this.get(dn);
        // the ldap client only returns an array when there are 2 or more elements
        // if there is only one element, it comes back as a scalar
        const attr = current.all(attribute);
        const existingValues = new Set(Array.isArray(attr) ? attr : [attr]);
        const oldValues = values.filter(v => existingValues.has(v));
        if (oldValues.length === 0)
            return true;
        return await this.modify(dn, 'delete', { type: attribute, values: oldValues });
    }
    async removeAttribute(dn, attribute) {
        return await this.modify(dn, 'delete', { type: attribute, values: [] });
    }
    /**
     * Use this method to add a member to a group. memberdn can be an array. each memberdn can be a group or a person.
     * Any memberdn entries that are already members will be ignored.
     */
    async addMember(memberdn, groupdn) {
        return await this.pushAttribute(groupdn, 'member', memberdn);
    }
    /**
     * Use this method to remove a member from a group. memberdn can be an array. each memberdn can be a group or a person.
     * Any memberdn entries that are not already members will be ignored.
     */
    async removeMember(memberdn, groupdn) {
        return await this.pullAttribute(groupdn, 'member', memberdn);
    }
    async getMemberRecur(ret, g, groupsExplored) {
        const members = await g.fullRange('member');
        const batchMap = batchOnBase(members.map(searchForDN));
        const groups = [];
        for (const [basedn, batches] of Object.entries(batchMap)) {
            for (const filter of batches) {
                const strm = this.stream(basedn, { scope: 'sub', filter });
                for await (const m of strm) {
                    const isGroup = m.one('member') != null;
                    if (isGroup)
                        groups.push(m);
                    else {
                        const feedme = ret.push(m);
                        if (!feedme) {
                            await new Promise(resolve => {
                                ret.on('resume', () => {
                                    ret.removeAllListeners('resume');
                                    resolve(undefined);
                                });
                            });
                        }
                    }
                }
            }
        }
        for (const sg of groups) {
            if (!groupsExplored.has(sg.dn)) {
                groupsExplored.add(sg.dn);
                await this.getMemberRecur(ret, sg, groupsExplored);
            }
        }
    }
    getMemberStream(groupdn) {
        const ret = new stream_1.Readable({ objectMode: true, highWaterMark: 100 });
        ret._read = () => { };
        this.get(groupdn).then(async (g) => {
            await this.getMemberRecur(ret, g, new Set(groupdn));
            ret.push(null);
        }).catch(e => ret.destroy(e));
        return ret;
    }
    async getMembers(groupdn) {
        const strm = this.getMemberStream(groupdn);
        const members = [];
        for await (const m of strm)
            members.push(m);
        return members;
    }
    templateLiteralEscape(regex, replacements, strings, values) {
        let safe = '';
        for (let i = 0; i < strings.length; i++) {
            safe += strings[i];
            if (values.length > i) {
                safe += `${values[i]}`.replace(new RegExp(regex.source, 'gm'), (ch) => replacements[ch]);
            }
        }
        return safe;
    }
    filter(strings, ...values) {
        return this.templateLiteralEscape(/[\0()*\\]/, filterReplacements, strings, values);
    }
    filterAllowWildcard(strings, ...values) {
        return this.templateLiteralEscape(/[\0()\\]/, filterReplacements, strings, values);
    }
    dn(strings, ...values) {
        return this.templateLiteralEscape(/((^ )|["#+,;<=>\\]|( $))/, dnReplacements, strings, values);
    }
    in(values, property) {
        return `(|${values.map(v => this.filter `(${property}=${v})`).join('')})`;
    }
    any(values, wildcards = false) {
        return wildcards
            ? `(|${Object.entries(values).map(([k, v]) => this.filterAllowWildcard `(${k}=${v})`).join('')})`
            : `(|${Object.entries(values).map(([k, v]) => this.filter `(${k}=${v})`).join('')})`;
    }
    all(values, wildcards = false) {
        return wildcards
            ? `(&${Object.entries(values).map(([k, v]) => this.filterAllowWildcard `(${k}=${v})`).join('')})`
            : `(&${Object.entries(values).map(([k, v]) => this.filter `(${k}=${v})`).join('')})`;
    }
    anyall(values, wildcards = false) {
        return wildcards
            ? `(|${values.map(v => `(&${Object.entries(v).map(([prop, val]) => this.filterAllowWildcard `(${prop}=${val})`).join('')})`).join('')})`
            : `(|${values.map(v => `(&${Object.entries(v).map(([prop, val]) => this.filter `(${prop}=${val})`).join('')})`).join('')})`;
    }
}
exports.default = Ldap;
const binaryAttributes = new Set(['photo', 'personalsignature', 'audio', 'jpegphoto', 'javaserializeddata', 'thumbnaildhoto', 'thumbnaillogo', 'userpassword', 'usercertificate', 'cacertificate', 'authorityrevocationlist', 'certificaterevocationlist', 'crosscertificatepair', 'x500uniqueidentifier']);
class LdapEntry {
    constructor(data, client) {
        this.client = client;
        this.attrs = new Map();
        this.dn = data.pojo.objectName;
        for (const attr of data.attributes) {
            const attrWithoutOptions = attr.type.split(';', 2)[0].toLocaleLowerCase();
            this.attrs.set(attrWithoutOptions, attr);
        }
    }
    get(attr) {
        return this.all(attr)[0];
    }
    one(attr) {
        return this.get(attr.toLocaleLowerCase());
    }
    first(attr) {
        return this.get(attr.toLocaleLowerCase());
    }
    all(attr) {
        var _a, _b;
        if (attr === 'dn')
            return [this.dn];
        return (_b = (_a = this.attrs.get(attr.toLocaleLowerCase())) === null || _a === void 0 ? void 0 : _a.values) !== null && _b !== void 0 ? _b : [];
    }
    buffer(attr) {
        var _a, _b;
        return (_b = (_a = this.attrs.get(attr.toLocaleLowerCase())) === null || _a === void 0 ? void 0 : _a.buffers) === null || _b === void 0 ? void 0 : _b[0];
    }
    buffers(attr) {
        var _a, _b;
        return (_b = (_a = this.attrs.get(attr.toLocaleLowerCase())) === null || _a === void 0 ? void 0 : _a.buffers) !== null && _b !== void 0 ? _b : [];
    }
    binary(attr) {
        return this.buffer(attr);
    }
    binaries(attr) {
        return this.buffers(attr);
    }
    isBinary(attr) {
        var _a;
        const lcAttr = attr.toLocaleLowerCase();
        return binaryAttributes.has(lcAttr) || this.options(lcAttr).includes('binary') || ((_a = this.attrs.get(lcAttr)) === null || _a === void 0 ? void 0 : _a.buffers.some(b => {
            try {
                utfDecoder.decode(b);
                return false;
            }
            catch {
                return true;
            }
        }));
    }
    options(attr) {
        var _a, _b, _c;
        (_a = this.optionsCache) !== null && _a !== void 0 ? _a : (this.optionsCache = (_b = this.attrs.get(attr.toLocaleLowerCase())) === null || _b === void 0 ? void 0 : _b.type.split(';').slice(1));
        return (_c = this.optionsCache) !== null && _c !== void 0 ? _c : [];
    }
    toJSON() {
        const obj = { dn: this.dn };
        for (const attr of this.attrs.values()) {
            if (attr.buffers.length > 0) {
                const lcAttr = attr.type.split(';', 2)[0].toLocaleLowerCase();
                if (this.isBinary(lcAttr)) {
                    if (attr.values.length === 1)
                        obj[lcAttr] = attr.buffers[0].toString('base64');
                    else
                        obj[lcAttr] = attr.buffers.map(b => b.toString('base64'));
                }
                else {
                    if (attr.values.length === 1)
                        obj[lcAttr] = attr.values[0];
                    else
                        obj[lcAttr] = attr.values;
                }
            }
        }
        return obj;
    }
    pojo() {
        return this.toJSON();
    }
    toString() {
        return JSON.stringify(this.toJSON(), null, 2);
    }
    async fullRange(attr) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let entry = this;
        const attrWithOptions = [attr, ...this.options(attr).filter(o => !o.startsWith('range='))].join(';');
        const ret = [];
        while (true) {
            ret.push(...entry.all(attr));
            const pageOpt = entry.options(attr).find(o => o.startsWith('range='));
            if (!pageOpt || pageOpt.endsWith('*') || entry.all(attr).length === 0)
                return ret;
            const [, rangeStr] = pageOpt.split('=');
            const [low, high] = rangeStr.split('-').map(Number);
            const pageSize = 1 + high - low;
            const newLow = high + 1;
            const newHigh = newLow + pageSize - 1;
            entry = (await this.client.load(this.dn, attrWithOptions + `;range=${newLow}-${newHigh}`));
        }
    }
}
exports.LdapEntry = LdapEntry;
